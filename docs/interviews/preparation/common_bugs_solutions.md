# Common Bugs & Solutions - Interview Favorites

**Contexto**: Bugs t√≠picos en entrevistas t√©cnicas
**Audiencia**: Senior Full-Stack Developer preparation
**Stack**: React + TypeScript + .NET Core

---

## Tabla de Contenidos

1. [React Bugs](#react-bugs)
2. [.NET/C# Bugs](#netc-bugs)
3. [Async/Await Pitfalls](#asyncawait-pitfalls)
4. [State Management Gotchas](#state-management-gotchas)

---

## React Bugs

### Bug #1: Mutaci√≥n Directa de Estado (CR√çTICO)

**Escenario real**: Checkbox no actualiza cuando se hace clic.

#### C√≥digo Problem√°tico

```tsx
import { useState } from 'react';

function TodoList() {
  const [items, setItems] = useState([
    { id: 1, title: 'Task 1', complete: false },
    { id: 2, title: 'Task 2', complete: false },
  ]);

  const handleToggle = (item) => {
    // üî¥ ERROR 1: Mutaci√≥n directa del array
    const indexFound = items.findIndex(i => i.title === item.title);

    // üî¥ ERROR 2: Modificar objeto directamente
    items[indexFound].complete = !items[indexFound].complete;

    // üî¥ ERROR 3: setItems recibe la MISMA referencia
    setItems(items); // React no detecta cambio
  };

  return (
    <ul>
      {items.map(item => (
        <li key={item.id}>
          <input
            type="checkbox"
            checked={item.complete}
            onChange={() => handleToggle(item)}
          />
          {item.title}: {item.complete ? 'Yes' : 'No'}
        </li>
      ))}
    </ul>
  );
}
```

#### ¬øPor Qu√© Falla?

React detecta cambios comparando **referencias**, no valores profundos:

```tsx
const arr1 = [1, 2, 3];
const arr2 = arr1;
arr2.push(4);

console.log(arr1 === arr2); // true (misma referencia)
// React piensa: "no cambi√≥, no re-renderizo"
```

#### Soluci√≥n Correcta (Inmutabilidad)

```tsx
const handleToggle = (item) => {
  // ‚úÖ Crear NUEVO array con map (inmutable)
  setItems(items.map(i =>
    i.id === item.id
      ? { ...i, complete: !i.complete } // nuevo objeto
      : i // mismo objeto si no coincide
  ));
};
```

#### Soluci√≥n Alternativa (filter + spread)

```tsx
const handleToggle = (item) => {
  // Encuentra el item
  const updatedItem = { ...item, complete: !item.complete };

  // Crea nuevo array reemplazando el item
  setItems([
    ...items.filter(i => i.id !== item.id),
    updatedItem
  ]);
};
```

#### C√≥digo Completo Corregido

```tsx
import React, { useState } from 'react';

function TodoList() {
  const [items, setItems] = useState([
    { id: 1, title: 'Task 1', complete: false, priority: 1 },
    { id: 2, title: 'Task 2', complete: false, priority: 2 },
  ]);

  // ‚úÖ Handler inmutable
  const handleToggle = (item) => {
    setItems(items.map(i =>
      i.id === item.id
        ? { ...i, complete: !i.complete }
        : i
    ));
  };

  // ‚úÖ Sort inmutable (crea nuevo array)
  const sortedItems = [...items].sort((a, b) => a.priority - b.priority);

  return (
    <table>
      <thead>
        <tr>
          <th>Title</th>
          <th>Priority</th>
          <th>Complete</th>
        </tr>
      </thead>
      <tbody>
        {sortedItems.map(item => (
          <tr key={item.id}>
            <td>{item.title}</td>
            <td>{item.priority}</td>
            <td>
              <input
                type="checkbox"
                checked={item.complete}
                onChange={() => handleToggle(item)}
              />
              {item.complete ? 'Yes' : 'No'}
            </td>
          </tr>
        ))}
      </tbody>
    </table>
  );
}

export default TodoList;
```

#### Regla de Oro: Operaciones Inmutables

```tsx
// ‚ùå NUNCA (mutan el original)
array.push(item);
array.pop();
array.splice(index, 1);
array[index] = newValue;
array.sort();
object.property = newValue;

// ‚úÖ SIEMPRE (crean nuevas referencias)
[...array, item]
array.slice(0, -1)
array.filter((_, i) => i !== index)
array.map((el, i) => i === index ? newValue : el)
[...array].sort()
{ ...object, property: newValue }
```

---

### Bug #2: useEffect Loop Infinito

#### C√≥digo Problem√°tico

```tsx
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);

  // üî¥ LOOP INFINITO
  useEffect(() => {
    fetchUser(userId).then(data => setUser(data));
  }, [user]); // user cambia ‚Üí efecto ejecuta ‚Üí user cambia...

  return <div>{user?.name}</div>;
}
```

#### Soluci√≥n

```tsx
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);

  // ‚úÖ Solo ejecutar cuando userId cambia
  useEffect(() => {
    fetchUser(userId).then(data => setUser(data));
  }, [userId]);

  return <div>{user?.name}</div>;
}
```

#### Variante: Objeto en Dependencias

```tsx
function DataFetcher({ filters }) {
  const [data, setData] = useState([]);

  // üî¥ LOOP - filters es nuevo objeto en cada render del padre
  useEffect(() => {
    fetchData(filters).then(setData);
  }, [filters]); // { dept: 'IT' } !== { dept: 'IT' }
}
```

**Soluciones**:

```tsx
// Opci√≥n 1: Destructurar dependencias espec√≠ficas
useEffect(() => {
  fetchData(filters).then(setData);
}, [filters.dept, filters.location]); // primitivos

// Opci√≥n 2: useMemo en el padre
const Parent = () => {
  const filters = useMemo(() => ({
    dept: 'IT',
    location: 'NY'
  }), []); // mismo objeto

  return <DataFetcher filters={filters} />;
};

// Opci√≥n 3: JSON.stringify (simple pero no ideal)
useEffect(() => {
  fetchData(filters).then(setData);
}, [JSON.stringify(filters)]);
```

---

### Bug #3: Stale Closures en Callbacks

#### C√≥digo Problem√°tico

```tsx
function Counter() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    // üî¥ count capturado del momento en que se cre√≥ la funci√≥n
    setTimeout(() => {
      setCount(count + 1); // siempre suma sobre valor viejo
    }, 1000);
  };

  // Click 3 veces r√°pido ‚Üí count = 1 (no 3)
  return <button onClick={handleClick}>Count: {count}</button>;
}
```

#### Soluci√≥n: Functional Update

```tsx
function Counter() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    // ‚úÖ Usa valor actual del estado
    setTimeout(() => {
      setCount(prev => prev + 1);
    }, 1000);
  };

  return <button onClick={handleClick}>Count: {count}</button>;
}
```

---

### Bug #4: Missing Key en Listas

#### C√≥digo Problem√°tico

```tsx
function TodoList({ items }) {
  return (
    <ul>
      {/* üî¥ Usar index como key causa bugs en listas din√°micas */}
      {items.map((item, index) => (
        <li key={index}>{item.name}</li>
      ))}
    </ul>
  );
}
```

**Problema**: Si items se reordenan, React confunde qu√© elemento es cu√°l.

#### Soluci√≥n

```tsx
function TodoList({ items }) {
  return (
    <ul>
      {/* ‚úÖ Usar ID √∫nico y estable */}
      {items.map(item => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  );
}
```

**Cu√°ndo est√° OK usar index**:
- Lista es est√°tica (nunca cambia)
- Items no tienen IDs √∫nicos
- No hay reordenamiento, filtrado o eliminaci√≥n

---

### Bug #5: Event Handlers sin useCallback (Rompe React.memo)

#### C√≥digo Problem√°tico

```tsx
function Parent() {
  const [count, setCount] = useState(0);

  // üî¥ Nueva funci√≥n en cada render
  const handleClick = () => {
    setCount(c => c + 1);
  };

  return (
    <div>
      <Child onClick={handleClick} /> {/* Child re-renderiza siempre */}
      <p>Count: {count}</p>
    </div>
  );
}

const Child = React.memo(({ onClick }) => {
  console.log('Child rendered');
  return <button onClick={onClick}>Click me</button>;
});
```

#### Soluci√≥n

```tsx
function Parent() {
  const [count, setCount] = useState(0);

  // ‚úÖ Funci√≥n estable
  const handleClick = useCallback(() => {
    setCount(c => c + 1);
  }, []);

  return (
    <div>
      <Child onClick={handleClick} /> {/* Child NO re-renderiza */}
      <p>Count: {count}</p>
    </div>
  );
}

const Child = React.memo(({ onClick }) => {
  console.log('Child rendered');
  return <button onClick={onClick}>Click me</button>;
});
```

---

## .NET/C# Bugs

### Bug #1: DbContext Inyectado como Singleton

#### C√≥digo Problem√°tico

```cs
// Startup.cs
// üî¥ ERROR - DbContext no debe ser Singleton
services.AddSingleton<ApplicationDbContext>();

// Controller
public class EmployeesController : ControllerBase
{
    private readonly ApplicationDbContext _context;

    public EmployeesController(ApplicationDbContext context)
    {
        _context = context; // Mismo contexto para TODOS los requests
    }
}
```

**Problema**:
- DbContext no es thread-safe
- Acumula entidades trackeadas (memory leak)
- Conexiones no se liberan

#### Soluci√≥n

```cs
// ‚úÖ SIEMPRE Scoped para DbContext
services.AddDbContext<ApplicationDbContext>(options =>
    options.UseSqlServer(connectionString));
```

---

### Bug #2: Olvidar AsNoTracking en Queries Read-Only

#### C√≥digo Problem√°tico

```cs
[HttpGet]
public async Task<IActionResult> GetEmployees()
{
    // üî¥ Tracking innecesario (30-40% m√°s lento)
    var employees = await _context.Employees
        .Include(e => e.Department)
        .ToListAsync();

    return Ok(employees);
}
```

#### Soluci√≥n

```cs
[HttpGet]
public async Task<IActionResult> GetEmployees()
{
    // ‚úÖ AsNoTracking para read-only
    var employees = await _context.Employees
        .AsNoTracking()
        .Include(e => e.Department)
        .ToListAsync();

    return Ok(employees);
}
```

---

### Bug #3: Comparaci√≥n de Strings Case-Sensitive

#### C√≥digo Problem√°tico

```cs
public bool IsAdmin(string role)
{
    // üî¥ Case-sensitive: "Admin" != "admin"
    return role == "Admin";
}
```

#### Soluci√≥n

```cs
public bool IsAdmin(string role)
{
    // ‚úÖ Case-insensitive
    return role?.Equals("Admin", StringComparison.OrdinalIgnoreCase) == true;

    // O m√°s corto:
    return string.Equals(role, "Admin", StringComparison.OrdinalIgnoreCase);
}
```

---

### Bug #4: Concatenar Strings en Loop

#### C√≥digo Problem√°tico

```cs
public string BuildReport(List<string> lines)
{
    string report = "";

    // üî¥ Crea nuevo string en cada iteraci√≥n (O(n¬≤))
    foreach (var line in lines)
    {
        report += line + "\n";
    }

    return report;
}
```

#### Soluci√≥n

```cs
public string BuildReport(List<string> lines)
{
    // ‚úÖ StringBuilder (O(n))
    var sb = new StringBuilder();

    foreach (var line in lines)
    {
        sb.AppendLine(line);
    }

    return sb.ToString();
}
```

---

## Async/Await Pitfalls

### Bug #1: async void (NUNCA uses esto)

#### C√≥digo Problem√°tico

```cs
// üî¥ PELIGRO - excepci√≥n no se puede capturar
public async void SendEmailAsync(string to, string body)
{
    await _emailService.SendAsync(to, body);
    throw new Exception("Email failed"); // crash silencioso
}

// Controller
[HttpPost("send")]
public IActionResult SendEmail(EmailRequest request)
{
    SendEmailAsync(request.To, request.Body); // fire-and-forget
    return Ok(); // no espera resultado
}
```

#### Soluci√≥n

```cs
// ‚úÖ SIEMPRE async Task (o async Task<T>)
public async Task SendEmailAsync(string to, string body)
{
    await _emailService.SendAsync(to, body);
}

// Controller
[HttpPost("send")]
public async Task<IActionResult> SendEmail(EmailRequest request)
{
    await SendEmailAsync(request.To, request.Body);
    return Ok();
}
```

**√önica excepci√≥n**: Event handlers en UI (WPF, WinForms).

---

### Bug #2: Deadlock con .Result o .Wait()

#### C√≥digo Problem√°tico

```cs
public IActionResult GetData()
{
    // üî¥ DEADLOCK en ASP.NET (pre-Core)
    var data = _service.GetDataAsync().Result;
    return Ok(data);
}
```

**Por qu√© deadlock**:
1. Thread principal espera en `.Result`
2. Async operation intenta volver al contexto original (ocupado)
3. Deadlock

#### Soluci√≥n

```cs
// ‚úÖ Usa async/await correctamente
public async Task<IActionResult> GetData()
{
    var data = await _service.GetDataAsync();
    return Ok(data);
}
```

**Nota**: En ASP.NET Core no hay deadlock (no hay SynchronizationContext), pero `.Result` sigue siendo mala pr√°ctica.

---

### Bug #3: Olvidar await

#### C√≥digo Problem√°tico

```cs
public async Task ProcessOrderAsync(int orderId)
{
    // üî¥ Olvid√≥ await - m√©todo retorna inmediatamente
    UpdateInventoryAsync(orderId); // fire-and-forget
    SendConfirmationEmailAsync(orderId); // fire-and-forget

    await _context.SaveChangesAsync(); // guarda antes de procesar
}
```

#### Soluci√≥n

```cs
public async Task ProcessOrderAsync(int orderId)
{
    // ‚úÖ Await todas las operaciones async
    await UpdateInventoryAsync(orderId);
    await SendConfirmationEmailAsync(orderId);
    await _context.SaveChangesAsync();
}

// O en paralelo si son independientes:
public async Task ProcessOrderAsync(int orderId)
{
    var inventoryTask = UpdateInventoryAsync(orderId);
    var emailTask = SendConfirmationEmailAsync(orderId);

    await Task.WhenAll(inventoryTask, emailTask);
    await _context.SaveChangesAsync();
}
```

---

## State Management Gotchas

### Bug #1: Zustand - Mutaci√≥n Directa del State

#### C√≥digo Problem√°tico

```tsx
import create from 'zustand';

const useStore = create((set) => ({
  items: [],
  addItem: (item) =>
    // üî¥ Mutaci√≥n directa
    set((state) => {
      state.items.push(item); // ¬°No!
      return state;
    }),
}));
```

#### Soluci√≥n

```tsx
const useStore = create((set) => ({
  items: [],
  addItem: (item) =>
    // ‚úÖ Inmutable
    set((state) => ({
      items: [...state.items, item]
    })),
}));
```

---

### Bug #2: Context Re-renders Innecesarios

#### C√≥digo Problem√°tico

```tsx
function AppProvider({ children }) {
  const [user, setUser] = useState(null);
  const [theme, setTheme] = useState('light');

  // üî¥ Nuevo objeto en cada render
  const value = { user, setUser, theme, setTheme };

  return (
    <AppContext.Provider value={value}>
      {children} {/* todos los consumers re-renderizan */}
    </AppContext.Provider>
  );
}
```

#### Soluci√≥n

```tsx
function AppProvider({ children }) {
  const [user, setUser] = useState(null);
  const [theme, setTheme] = useState('light');

  // ‚úÖ Memoizar value
  const value = useMemo(
    () => ({ user, setUser, theme, setTheme }),
    [user, theme]
  );

  return (
    <AppContext.Provider value={value}>
      {children}
    </AppContext.Provider>
  );
}
```

---

### üß† Key Insight

> **Los bugs m√°s comunes en entrevistas no son los m√°s complejos ‚Äî son los que revelan falta de comprensi√≥n de fundamentos. Mutar estado en React, usar .Result en async code, o inyectar DbContext como Singleton son errores que un Senior nunca deber√≠a cometer. Conocer estos patrones de memoria separa candidatos que "saben React" de los que "entienden React".**

---

## Checklist Anti-Bugs

**Antes de cada commit, pregunta**:

### React
- [ ] ¬øEstoy mutando estado directamente? (usa spread/map)
- [ ] ¬øMis useEffect tienen dependencias correctas?
- [ ] ¬øPas√© callbacks a React.memo sin useCallback?
- [ ] ¬øUso index como key en lista din√°mica?

### .NET
- [ ] ¬øDbContext es Scoped? (nunca Singleton)
- [ ] ¬øUs√© AsNoTracking en queries read-only?
- [ ] ¬øTodos mis m√©todos async retornan Task (no void)?
- [ ] ¬øEstoy usando await en lugar de .Result?

### General
- [ ] ¬øHay memory leaks potenciales? (event listeners, timers)
- [ ] ¬øManej√© todos los casos edge? (null, vac√≠o, error)
- [ ] ¬øEl c√≥digo es inmutable donde debe serlo?

---

**Recursos adicionales**:
- [React Common Mistakes](https://react.dev/learn/you-might-not-need-an-effect)
- [Async Best Practices](https://learn.microsoft.com/en-us/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming)
